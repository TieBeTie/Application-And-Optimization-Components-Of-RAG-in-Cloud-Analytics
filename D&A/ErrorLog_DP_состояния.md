# ErrorLog: DP — состояния и порядок перебора

**Задача-триггер:** [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)

---

## Ошибка: перебор всех конфигураций вместо достижимых состояний

### Как думал (неправильно)

> "Нужно перебрать все подмножества и проверить, какие дают нужную сумму"

```
Все подмножества {1,2,3}:
{}, {1}, {2}, {3}, {1,2}, {1,3}, {2,3}, {1,2,3}
→ O(2^n) состояний
```

### Как надо думать

> "Какие **суммы** вообще достижимы? Пушим новые суммы из уже достигнутых"

```
Достижимые суммы для [1,2,3]:
Старт: {0}
+1:    {0, 1}
+2:    {0, 1, 2, 3}
+3:    {0, 1, 2, 3, 4, 5, 6}
→ O(n × sum) состояний
```

### Ключевой переход

| Плохо | Хорошо |
|-------|--------|
| "Какие **подмножества** существуют?" | "Какие **суммы** достижимы?" |
| Состояние = конфигурация (битовая маска) | Состояние = значение (число) |
| O(2^n) | O(n × sum) |

---

## Ошибка: неправильный порядок перебора

### Проблема

Кажется, что порядок важен: "сначала решаем, брать ли элемент 1, потом элемент 2..."

Но сумма **коммутативна**: `a + b + c = c + a + b`

### Инсайт

> Порядок слагаемых не меняет сумму → можно **зафиксировать позицию** элемента

Представляем, что каждый элемент "в конце" (или "в начале") — это позволяет:
1. Итерировать по элементам последовательно
2. Для каждого элемента "отщипывать" от текущих достижимых состояний
3. Не думать о перестановках

### Паттерн кода

```python
def canPartition(nums):
    total = sum(nums)
    if total % 2 != 0:
        return False

    target = total // 2
    reachable = {0}  # достижимые суммы

    for num in nums:
        # пушим новые состояния из достигнутых
        new_reachable = set()
        for s in reachable:
            new_reachable.add(s + num)
        reachable |= new_reachable

        if target in reachable:
            return True

    return False
```

---

## Обобщение: два принципа DP

### Принцип 1: Состояния — это достижимые значения

- **Не** перебирай все возможные конфигурации
- **Да** храни множество достижимых состояний и пуши новые

### Принцип 2: Фиксируй порядок, если операция коммутативна

- Сумма, произведение, XOR, объединение множеств — порядок не важен
- Можно итерировать по элементам в любом порядке
- Это сжимает пространство состояний

---

## Когда применять

- Задачи на подмножества с суммой/произведением
- Knapsack-подобные задачи
- Любое DP, где состояние — это "значение", а не "путь до значения"

---

## Связанные задачи

- [Partition Equal Subset Sum](https://leetcode.com/problems/partition-equal-subset-sum/)
- [Target Sum](https://leetcode.com/problems/target-sum/)
- [Coin Change](https://leetcode.com/problems/coin-change/)
- [Subset Sum](https://leetcode.com/problems/subsets/)
