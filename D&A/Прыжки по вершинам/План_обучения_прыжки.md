# План самостоятельного решения: "Прыжки по вершинам"

## Цель плана
Построить интуитивное понимание решения через последовательность небольших шагов, где каждый следующий шаг **естественно вытекает** из предыдущего.

---

# Часть 1: Возврат к предыдущему решению

### Шаг 1.1: Вспомни, что мы делали раньше

В прошлый раз мы пытались решить задачу через **монотонные очереди на дереве отрезков**.

**Вопрос:** Что мы хранили в каждой вершине? По какому компаратору строили очередь?

---

### Шаг 1.2: Посмотри ещё раз на примеры

**Задание:** Нарисуй на бумаге 5 зубцов с высотами `[3, 1, 4, 2, 5]`.

1. Отметь, куда можно прыгнуть с зубца 1
2. Отметь, куда можно прыгнуть с зубца 3
3. Нарисуй оптимальный путь из 1 в 5

**Самопроверка:** С зубца 1 можно прыгнуть на 2, 3, 5, но НЕ на 4. Почему?

---

### Шаг 1.3: Геометрическая интерпретация прыжка

**Наблюдение:** Прыжок с `i` на `j` возможен тогда и только тогда, когда...

**Задание:** Проведи отрезок `(i, h_i) → (j, h_j)`. Что должно выполняться для всех точек между ними?

<details>
<summary>Ответ</summary>

Все промежуточные вершины `(k, h_k)` должны лежать **НЕ ВЫШЕ** этого отрезка.

Отрезок должен идти "над" всеми промежуточными зубцами.
</details>

---

### Шаг 1.4: Что за структуру мы строим?

**Задание:** Для массива `[2, 5, 3, 7, 4, 6, 1, 8]`:
1. Начни с точки (1, 2)
2. Соедини все точки, через которые проходит **оптимальный путь** (с минимумом прыжков)

**Нарисуй эту ломаную. Посмотри на неё сверху.**

<details>
<summary>Что получилось?</summary>

Это **верхняя выпуклая оболочка** точек!

Минимальное число прыжков = число рёбер этой оболочки = число вершин − 1.
</details>

---

### Шаг 1.5: Возврат к монотонным очередям

**Вопрос:** Если это выпуклая оболочка, то что на самом деле делала наша монотонная очередь?

<details>
<summary>Ответ</summary>

Мы по сути строили выпуклую оболочку, но не понимали этого!

Компаратор "по углу между соседними вершинами" — это в точности условие выпуклости.

**Вывод:** Монотонные очереди на дереве отрезков — это **переусложнение**. Мы изобретали выпуклую оболочку сложным путём.
</details>

---

# Часть 2: Как описать выпуклую оболочку?

### Шаг 2.1: Что общего у всех рёбер оболочки?

**Задание:** Посмотри на свой рисунок оболочки. Пройдись по рёбрам слева направо.

В каждой вершине ты поворачиваешь. **В какую сторону?**

<details>
<summary>Наблюдение</summary>

В каждой вершине верхней выпуклой оболочки происходит поворот **направо** (по часовой стрелке).

Если бы был поворот налево — точка была бы "внутри", а не на оболочке.
</details>

---

### Шаг 2.2: Как определить направление поворота?

**Задание:** Даны три точки A, B, C. Как понять, поворот A→B→C идёт направо или налево?

Нарисуй несколько примеров:
```
Пример 1:          Пример 2:          Пример 3:
    C                  B                  B---C
   /                  / \                /
  B                  A   C              A
 /
A
Направо?           Налево?            Прямо?
```

---

### Шаг 2.3: Выведи формулу поворота

**Задание:** Пусть A = (x₁, y₁), B = (x₂, y₂), C = (x₃, y₃).

1. Найди вектор AB = ?
2. Найди вектор BC = ?
3. Вспомни из школы: как определить, с какой стороны от прямой лежит точка?

<details>
<summary>Подсказка 1</summary>

Это связано с **площадью** треугольника ABC. Площадь со знаком!
</details>

<details>
<summary>Подсказка 2</summary>

Формула площади через координаты:
```
S = (1/2) * |x₁(y₂ - y₃) + x₂(y₃ - y₁) + x₃(y₁ - y₂)|
```
Без модуля — площадь со знаком.
</details>

<details>
<summary>Формула</summary>

```
rotate(A, B, C) = (x₂ - x₁)(y₃ - y₂) - (y₂ - y₁)(x₃ - x₂)
```

- `rotate > 0` → поворот **налево**
- `rotate < 0` → поворот **направо**
- `rotate = 0` → точки на одной прямой

Это **косое произведение** (или "псевдоскалярное произведение") векторов AB и BC.
</details>

---

### Шаг 2.4: Проверь понимание

**Задание:** Для точек A = (1, 2), B = (3, 5), C = (5, 4):
1. Вычисли rotate(A, B, C)
2. Определи направление поворота
3. Нарисуй и проверь визуально

---

# Часть 3: Почему предпосчёт "в лоб" не работает

### Шаг 3.1: Наивный алгоритм

**Сложность:** Для каждого запроса `(l, r)` построить выпуклую оболочку за `O(r - l)`.

При `q = 10^5` запросах: **O(n × q) = 10^{10}** — не проходит.

---

### Шаг 3.2: Можно ли предпосчитать все оболочки?

**Вопрос:** Сколько существует различных отрезков `[l, r]`?

<details>
<summary>Ответ</summary>

`n(n-1)/2 ≈ n²/2` отрезков.

При `n = 10^5` это **5 × 10^9** — не влезет в память, даже если каждая оболочка занимает 1 байт.
</details>

---

### Шаг 3.3: Ключевой вопрос

Нам нужен способ:
- **Препроцессинг:** предпосчитать что-то за `O(n log n)` или `O(n log² n)`
- **Query:** отвечать на запрос быстрее, чем за `O(n)`

Как этого добиться?

---

# Часть 4: Divide & Conquer для препроцессинга

### Шаг 4.1: Идея разбиения

**Вопрос:** Если я знаю оболочку левой половины `[l, m]` и правой `[m+1, r]`, могу ли я получить оболочку `[l, r]`?

**Нарисуй пример:**
```
Левая оболочка:     Правая оболочка:
    *                       *
   / \                     /
  *   *                   *
```

---

### Шаг 4.2: Что нужно сделать при склейке?

**Задание:** Нарисуй две оболочки рядом. Что нужно найти, чтобы их объединить?

<details>
<summary>Ответ</summary>

Нужно найти **верхнюю касательную** — прямую, которая:
1. Касается левой оболочки в некоторой точке P
2. Касается правой оболочки в некоторой точке Q
3. Все остальные точки обеих оболочек лежат **ниже** этой прямой

После этого: берём левую оболочку до P, добавляем ребро PQ, берём правую оболочку после Q.
</details>

---

### Шаг 4.3: Как искать касательную? (наведение на мысль)

**Задание:** Нарисуй такой пример:

```
Левая:              Правая:
      B                   D
     /                   / \
    A                   C   E
```

1. Где находится касательная? (между какими точками?)
2. Начни с точек B и C. Прямая BC — это касательная?
3. Если нет, в какую сторону нужно "подвинуть" точки?

---

### Шаг 4.4: Эксперимент с примером

**Задание:** Продолжи эксперимент. Нарисуй ещё 2-3 примера с разными конфигурациями.

Попробуй сформулировать **правило**: когда нужно двигать левую точку влево? Когда — правую точку вправо?

<details>
<summary>Подсказка</summary>

Используй функцию `rotate`!

Если `rotate(prev_P, P, Q) ≤ 0`, то точка prev_P лежит **выше** прямой PQ. Значит, P — не касательная точка для левой оболочки.
</details>

<details>
<summary>Алгоритм (после того как сам сформулировал)</summary>

1. Начни с правого конца левой оболочки (P) и левого конца правой (Q)
2. Пока `rotate(prev_P, P, Q) ≤ 0`: сдвинь P влево
3. Пока `rotate(P, Q, next_Q) ≤ 0`: сдвинь Q вправо
4. Повтори шаги 2-3, пока что-то меняется
5. Когда ничего не меняется — нашли касательную!
</details>

---

### Шаг 4.5: Сложность препроцессинга

**Вопрос:** Если мы рекурсивно делим отрезок пополам и склеиваем оболочки, какова сложность?

<details>
<summary>Анализ</summary>

- Глубина рекурсии: `O(log n)`
- На каждом уровне суммарно `O(n)` точек
- Склейка амортизированно линейна (каждая точка удаляется максимум один раз)

**Итого:** `O(n log n)` на препроцессинг.
</details>

---

# Часть 5: Query — зачем нужны "маленькие" оболочки

### Шаг 5.1: Контрпример

**Задание:** Рассмотри массив в форме буквы "U":
```
Высоты: [100, 1, 1, 1, ..., 1, 1, 100]
              ←— n-2 единиц —→
```

1. Сколько вершин на оболочке **всего** отрезка `[1, n]`?
2. Сколько вершин на оболочке отрезка `[2, n-1]`?

<details>
<summary>Ответ</summary>

1. Всего 2 вершины (два "столбика")
2. Все `n-2` единички! Это много.

**Вывод:** Оболочка подотрезка может быть **гораздо больше**, чем оболочка всего отрезка.
</details>

---

### Шаг 5.2: Что хранить для ответа на query?

**Вопрос:** Мы построили оболочку всего отрезка `[1, n]`. Но для query `[2, n-1]` она бесполезна. Что делать?

<details>
<summary>Идея</summary>

Нужно хранить **иерархию оболочек**:
- Оболочка `[1, n]`
- Оболочки `[1, n/2]` и `[n/2+1, n]`
- Оболочки `[1, n/4]`, `[n/4+1, n/2]`, ...
- ...и так далее до отдельных точек

Это **не дерево отрезков** (мы не делаем update), а статическая структура для ответа на range-запросы.
</details>

---

### Шаг 5.3: Как отвечать на query?

**Задание:** Запрос `[l, r]` покрывается несколькими "каноническими" отрезками из нашей иерархии.

1. Сколько таких отрезков? `O(?)`
2. Каждый имеет свою предпосчитанную оболочку
3. Как получить оболочку `[l, r]`?

<details>
<summary>Ответ</summary>

1. `O(log n)` отрезков покрывают любой query
2. Нужно **склеить** эти `O(log n)` оболочек
3. Склейка — тот же алгоритм с касательными!
</details>

---

### Шаг 5.4: Сложность query

**Вопрос:** Какова сложность одного query в худшем случае?

<details>
<summary>Анализ</summary>

- `O(log n)` оболочек
- Суммарный размер может быть до `O(n)` (контрпример с "U")
- Склейка линейна от суммарного размера

**Худший случай:** `O(n)` на query.

Это можно улучшить до `O(log² n)` с помощью дополнительных техник (бинарный поиск по оболочке, fractional cascading), но для олимпиады часто достаточно этого решения.
</details>

---

# Часть 6: Доказательство корректности склейки

### Шаг 6.1: Почему алгоритм находит касательную?

**Задание:** Докажи следующие утверждения:

**Утверждение 1:** Алгоритм всегда завершается.

<details>
<summary>Подсказка</summary>

На каждом шаге либо P сдвигается влево, либо Q вправо. Точки конечны.
</details>

---

### Шаг 6.2: Почему результат — касательная?

**Утверждение 2:** Когда алгоритм остановился, прямая PQ — касательная.

<details>
<summary>Доказательство</summary>

Алгоритм остановился, значит:
- `rotate(prev_P, P, Q) > 0` — точка prev_P лежит **ниже** прямой PQ
- `rotate(P, Q, next_Q) > 0` — точка next_Q лежит **ниже** прямой PQ

Поскольку оболочки выпуклые, **все** точки левой оболочки левее P лежат ниже PQ (индукция по выпуклости).

Аналогично для правой оболочки.
</details>

---

# Часть 7: Чеклист и упражнения

## Чеклист для самопроверки

- [ ] Понимаю, почему минимум прыжков = вершины оболочки − 1
- [ ] Понимаю связь между монотонными очередями и выпуклой оболочкой
- [ ] Могу вычислить `rotate(A, B, C)` и объяснить смысл знака
- [ ] Могу нарисовать пример склейки двух оболочек
- [ ] Понимаю, почему начинаем с правых/левых концов оболочек
- [ ] Могу объяснить контрпример с "U", зачем нужны маленькие оболочки
- [ ] Могу оценить сложность: препроцессинг `O(n log n)`, query до `O(n)`

---

## Упражнения для закрепления

1. **Ручной трейс:** Для массива `[4, 2, 5, 1, 6, 3, 7]`:
   - Построй иерархию оболочек
   - Ответь на запрос `(2, 6)`

2. **Контрпример:** Придумай массив, где оболочка `[1, n]` имеет 2 вершины, но оболочка `[2, n-1]` имеет 5+ вершин.

3. **Поворот:** Для точек (0,0), (2,3), (4,1) вычисли rotate и проверь визуально.

4. **Касательная:** Нарисуй две оболочки по 4 точки каждая. Найди касательную алгоритмом, который ты сформулировал.

---

## Дополнительные ресурсы

1. [cp-algorithms: Convex Hull Trick](https://cp-algorithms.com/geometry/convex_hull_trick.html)
2. [Codeforces: Tutorial on Convex Hull Trick](https://codeforces.com/blog/entry/63823)
3. [Two-Finger Algorithm](https://jayjingyuliu.wordpress.com/2018/01/24/algorithm-two-finger-convex-hull-merging-algorithm/)
